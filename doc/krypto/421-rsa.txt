RSA

Algoritme
  p tilfeldig primtall, ≥150 siffer
  q tilfeldig primtall, ≥150 siffer, omtrent like stort som p
  n modulus, ≥300 siffer
  e public eksponent 65537, ingen felles faktor med ϕ (n)
  d privat eksponent

  # Step 1
  A genererer p₁=53
  A genererer p₂=59
  A beregner n=53*59=3127

  # Step 2
  A beregner ϕ (n) = ϕ (3127) = ϕ (53*59) = ϕ (53) * ϕ (59) = 52*58 = 3016

  # Step 3
  A velger e=3
  A beregner d=k*ϕ (n)+1/e = (2*3016+1)/3 = 2011

  # Step 4
  A sender n=3127 og e=3 til B
  B beregner c = m^e mod n = 89^3 mod 3127 = 1394
  B sender c=1394 til A
  A beregner m = c^d mod n = 1394^2011 mod 3127 = 1394
  
Inverse funksjoner
  f(x) = x^d mod n (privat nøkkel)
  f(x) = x^e mod n (public nøkkel)

Kryptering
  f(m) = m^e mod n = c
  f(c) = c^d mod n = m

Signatur
  f(m) = pad(hash(m))^d = s
  f(s) = s^e = pad(hash(m))

Utledning
  Step 1: Primtallfaktorisering
  n = p*q                           

  Step 2: Eulers phi-funksjon
  ϕ (n) = ?                         ϕ (n) er generelt vanskelig
  ϕ (n) = ϕ (p*q)                   men for primtall er det enkelt
  ϕ (n) = ϕ (p) * ϕ (q)             ϕ (n) er multiplikativ
  ϕ (n) = (p-1) * (q-1)             enkelt hvis man kjenner p og q

  Step 3: Modulær eksponensiering
  m^ϕ (n) = 1 mod n                 eulers teorem
  m^k*ϕ (n) = 1^k mod n = 1 mod n   opphøyer i k på begge sider
  m*m^k*ϕ (n) = m*1^k mod n         ganger med m på begge sider
  m^k*ϕ (n)+1 = m mod n             dette var Cox sitt gjennombrudd
  e*d = k*ϕ (n)+1                   følger av m^e*d = m mod n
  d = k*ϕ (n)+1 / e                 d er en trapdoor for å reversere e

