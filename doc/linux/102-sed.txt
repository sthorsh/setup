SED

Usage
  sed [opts] '[addr]sedcmd[opts]' [files]

Options
  -E 
  -e sedcmd
  -f sedscript
  -i[suffix]
  -n 

Address
  N             line N
  $             last line
  /regexp/      match        
  /regexp/!     not match
  addr₁,addr₂   range
  addr₁,+N      addr₁ + N lines

Sedcmds 
  a text        append after line
  c text        change (replace) line
  d             delete line
  i text        insert before line
  s/r/t/f       substitute regexp r, with text t, using flags f
  

  
----------------------------------------------------------------------------------------
REGULAR EXPRESSIONS
       POSIX.2  BREs  should  be supported, but they aren't completely because of performance problems.  The \n
       sequence in a regular expression matches the newline character, and similarly  for  \a,  \t,  and  other
       sequences.  The -E option switches to using extended regular expressions instead; the -E option has been
       supported for years by GNU sed, and is now included in POSIX.

----------------------------------------------------------------------------------------
ZERO-ADDRESS ``COMMANDS''
    : label
           Label for b and t commands.

    #comment
           The comment extends until the next newline (or the end of a -e script fragment).

    }      The closing bracket of a { } block.

ZERO- OR ONE- ADDRESS COMMANDS
    =      Print the current line number.

    q [exit-code]
           Immediately  quit  the sed script without processing any more input, except that if auto-print is
           not disabled the current pattern space will be printed.  The exit code argument is a  GNU  exten‐
           sion.

    Q [exit-code]
           Immediately quit the sed script without processing any more input.  This is a GNU extension.

    r filename
           Append text read from filename.

    R filename
           Append  a  line  read  from filename.  Each invocation of the command reads a line from the file.
           This is a GNU extension.

COMMANDS WHICH ACCEPT ADDRESS RANGES
    {      Begin a block of commands (end with a }).

    b label
           Branch to label; if label is omitted, branch to end of script.

    D      If pattern space contains no newline, start a normal new cycle as if the d  command  was  issued.
           Otherwise,  delete  text in the pattern space up to the first newline, and restart cycle with the
           resultant pattern space, without reading a new line of input.

    h H    Copy/append pattern space to hold space.

    g G    Copy/append hold space to pattern space.

    l      List out the current line in a ``visually unambiguous'' form.

    l width
           List out the current line in a ``visually unambiguous'' form, breaking it  at  width  characters.
           This is a GNU extension.

    n N    Read/append the next line of input into the pattern space.

    p      Print the current pattern space.

    P      Print up to the first embedded newline of the current pattern space.

    t label
           If a s/// has done a successful substitution since the last input line was  read  and  since  the
           last t or T command, then branch to label; if label is omitted, branch to end of script.

    T label
           If  no  s///  has done a successful substitution since the last input line was read and since the
           last t or T command, then branch to label; if label is omitted, branch to end of script.  This is
           a GNU extension.

    w filename
           Write the current pattern space to filename.

    W filename
           Write the first line of the current pattern space to filename.  This is a GNU extension.

    x      Exchange the contents of the hold and pattern spaces.

    y/sourcje/dest/
           Transliterate  the  characters  in  the pattern space which appear in source to the corresponding
           character in dest.

